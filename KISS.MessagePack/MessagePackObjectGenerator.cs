using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace KISS.MessagePack
{
    [Generator]
    public class MessagePackObjectGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
                return;

            var attributeSymbol = context.Compilation.GetTypeByMetadataName("KISS.MessagePack.MessagePackObjectGeneratorAttribute");
            if (attributeSymbol == null)
                return;

            var processedClasses = new List<(INamedTypeSymbol Symbol, ClassDeclarationSyntax Declaration)>();

            foreach (var classDeclaration in receiver.CandidateClasses)
            {
                var semanticModel = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);

                if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                    continue;

                if (!classSymbol.GetAttributes().Any(attr =>
                    SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeSymbol)))
                    continue;

                processedClasses.Add((classSymbol, classDeclaration));

                var source = GenerateMessagePackAttributes(classSymbol);
                if (!string.IsNullOrEmpty(source))
                {
                    context.AddSource($"{classSymbol.Name}.MessagePack.g.cs", SourceText.From(source, Encoding.UTF8));
                }
            }

            // Generate the generic extensions class once
            if (processedClasses.Any())
            {
                var extensionsSource = GenerateGenericExtensions(processedClasses);
                context.AddSource("MessagePackExtensions.g.cs", SourceText.From(extensionsSource, Encoding.UTF8));
            }
        }

        private string GenerateMessagePackAttributes(INamedTypeSymbol classSymbol)
        {
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            var properties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                           p.GetMethod != null && p.SetMethod != null)
                .ToList();

            if (!properties.Any())
                return string.Empty;

            var sourceBuilder = new StringBuilder();

            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// This file contains the MessagePack attributes for your class.");
            sourceBuilder.AppendLine("// Copy these attributes to your original class definition.");
            sourceBuilder.AppendLine("using MessagePack;");
            sourceBuilder.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
            {
                sourceBuilder.AppendLine($"namespace {namespaceName}");
                sourceBuilder.AppendLine("{");
            }

            var indent = string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>" ? "" : "    ";

            // Generate comments showing what the class should look like
            sourceBuilder.AppendLine($"{indent}/*");
            sourceBuilder.AppendLine($"{indent} * Copy these attributes to your {className} class:");
            sourceBuilder.AppendLine($"{indent} *");
            sourceBuilder.AppendLine($"{indent} * [MessagePackObject]");
            sourceBuilder.AppendLine($"{indent} * public partial class {className}");
            sourceBuilder.AppendLine($"{indent} * {{");

            for (int i = 0; i < properties.Count; i++)
            {
                var property = properties[i];
                sourceBuilder.AppendLine($"{indent} *     [Key({i})]");
                sourceBuilder.AppendLine($"{indent} *     public {property.Type.ToDisplayString()} {property.Name} {{ get; set; }}");

                if (i < properties.Count - 1)
                    sourceBuilder.AppendLine($"{indent} *");
            }

            sourceBuilder.AppendLine($"{indent} * }}");
            sourceBuilder.AppendLine($"{indent} */");

            // Generate a working version that can be used immediately
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"{indent}// Temporary working version - use this class for MessagePack operations:");
            sourceBuilder.AppendLine($"{indent}[MessagePackObject]");
            sourceBuilder.AppendLine($"{indent}public class {className}MessagePackGenerated");
            sourceBuilder.AppendLine($"{indent}{{");

            for (int i = 0; i < properties.Count; i++)
            {
                var property = properties[i];
                sourceBuilder.AppendLine($"{indent}    [Key({i})]");
                sourceBuilder.AppendLine($"{indent}    public {property.Type.ToDisplayString()} {property.Name} {{ get; set; }}");

                if (i < properties.Count - 1)
                    sourceBuilder.AppendLine();
            }

            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"{indent}    // Conversion methods");
            sourceBuilder.AppendLine($"{indent}    public static implicit operator {className}MessagePackGenerated({className} source)");
            sourceBuilder.AppendLine($"{indent}    {{");
            sourceBuilder.AppendLine($"{indent}        return new {className}MessagePackGenerated");
            sourceBuilder.AppendLine($"{indent}        {{");

            for (int i = 0; i < properties.Count; i++)
            {
                var property = properties[i];
                sourceBuilder.AppendLine($"{indent}            {property.Name} = source.{property.Name}{(i < properties.Count - 1 ? "," : "")}");
            }

            sourceBuilder.AppendLine($"{indent}        }};");
            sourceBuilder.AppendLine($"{indent}    }}");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"{indent}    public static implicit operator {className}({className}MessagePackGenerated source)");
            sourceBuilder.AppendLine($"{indent}    {{");
            sourceBuilder.AppendLine($"{indent}        return new {className}");
            sourceBuilder.AppendLine($"{indent}        {{");

            for (int i = 0; i < properties.Count; i++)
            {
                var property = properties[i];
                sourceBuilder.AppendLine($"{indent}            {property.Name} = source.{property.Name}{(i < properties.Count - 1 ? "," : "")}");
            }

            sourceBuilder.AppendLine($"{indent}        }};");
            sourceBuilder.AppendLine($"{indent}    }}");

            sourceBuilder.AppendLine($"{indent}}}");

            if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
            {
                sourceBuilder.AppendLine("}");
            }

            return sourceBuilder.ToString();
        }

        private string GenerateGenericExtensions(List<(INamedTypeSymbol Symbol, ClassDeclarationSyntax Declaration)> processedClasses)
        {
            var sourceBuilder = new StringBuilder();

            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("using MessagePack;");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine();

            // Get the first namespace (assuming all classes are in the same namespace for simplicity)
            var firstNamespace = processedClasses.First().Symbol.ContainingNamespace.ToDisplayString();
            var hasNamespace = !string.IsNullOrEmpty(firstNamespace) && firstNamespace != "<global namespace>";

            if (hasNamespace)
            {
                sourceBuilder.AppendLine($"namespace {firstNamespace}");
                sourceBuilder.AppendLine("{");
            }

            var indent = hasNamespace ? "    " : "";

            sourceBuilder.AppendLine($"{indent}/// <summary>");
            sourceBuilder.AppendLine($"{indent}/// Generic extension methods for MessagePack serialization of MessagePackObjectGeneratorAttribute classes");
            sourceBuilder.AppendLine($"{indent}/// </summary>");
            sourceBuilder.AppendLine($"{indent}public static class MessagePackExtensions");
            sourceBuilder.AppendLine($"{indent}{{");

            // Generate generic ToMessagePack method
            sourceBuilder.AppendLine($"{indent}    /// <summary>");
            sourceBuilder.AppendLine($"{indent}    /// Serializes any MessagePackObjectGeneratorAttribute object to MessagePack format");
            sourceBuilder.AppendLine($"{indent}    /// </summary>");
            sourceBuilder.AppendLine($"{indent}    /// <typeparam name=\"T\">The type of object to serialize</typeparam>");
            sourceBuilder.AppendLine($"{indent}    /// <param name=\"obj\">The object to serialize</param>");
            sourceBuilder.AppendLine($"{indent}    /// <returns>MessagePack serialized byte array</returns>");
            sourceBuilder.AppendLine($"{indent}    public static byte[] Serialize<T>(this T obj)");
            sourceBuilder.AppendLine($"{indent}    {{");
            sourceBuilder.AppendLine($"{indent}        if (obj == null) throw new ArgumentNullException(nameof(obj));");
            sourceBuilder.AppendLine();

            // Generate switch statement for each type
            sourceBuilder.AppendLine($"{indent}        return obj switch");
            sourceBuilder.AppendLine($"{indent}        {{");

            foreach (var (symbol, _) in processedClasses)
            {
                var className = symbol.Name;
                sourceBuilder.AppendLine($"{indent}            {className} {className.ToLower()} => MessagePackSerializer.Serialize(({className}MessagePackGenerated){className.ToLower()}),");
            }

            sourceBuilder.AppendLine($"{indent}            _ => throw new NotSupportedException($\"Type {{typeof(T).Name}} is not supported for MessagePack serialization. Make sure the class is marked with [MessagePackObjectGenerator] attribute.\")");
            sourceBuilder.AppendLine($"{indent}        }};");
            sourceBuilder.AppendLine($"{indent}    }}");
            sourceBuilder.AppendLine();

            // Generate generic FromMessagePack method
            sourceBuilder.AppendLine($"{indent}    /// <summary>");
            sourceBuilder.AppendLine($"{indent}    /// Deserializes MessagePack data to the specified type");
            sourceBuilder.AppendLine($"{indent}    /// </summary>");
            sourceBuilder.AppendLine($"{indent}    /// <typeparam name=\"T\">The type to deserialize to</typeparam>");
            sourceBuilder.AppendLine($"{indent}    /// <param name=\"data\">The MessagePack byte array</param>");
            sourceBuilder.AppendLine($"{indent}    /// <returns>Deserialized object of type T</returns>");
            sourceBuilder.AppendLine($"{indent}    public static T Deserialize<T>(byte[] data)");
            sourceBuilder.AppendLine($"{indent}    {{");
            sourceBuilder.AppendLine($"{indent}        if (data == null) throw new ArgumentNullException(nameof(data));");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine($"{indent}        var typeName = typeof(T).Name;");
            sourceBuilder.AppendLine($"{indent}        return typeName switch");
            sourceBuilder.AppendLine($"{indent}        {{");

            foreach (var (symbol, _) in processedClasses)
            {
                var className = symbol.Name;
                sourceBuilder.AppendLine($"{indent}            \"{className}\" => (T)(object)({className})MessagePackSerializer.Deserialize<{className}MessagePackGenerated>(data),");
            }

            sourceBuilder.AppendLine($"{indent}            _ => throw new NotSupportedException($\"Type {{typeName}} is not supported for MessagePack deserialization. Make sure the class is marked with [MessagePackObjectGenerator] attribute.\")");
            sourceBuilder.AppendLine($"{indent}        }};");
            sourceBuilder.AppendLine($"{indent}    }}");

            sourceBuilder.AppendLine($"{indent}}}");

            if (hasNamespace)
            {
                sourceBuilder.AppendLine("}");
            }

            return sourceBuilder.ToString();
        }
    }

    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.AttributeLists.Count > 0)
            {
                foreach (var attributeList in classDeclaration.AttributeLists)
                {
                    foreach (var attribute in attributeList.Attributes)
                    {
                        var attributeName = attribute.Name.ToString();
                        if (attributeName == "MessagePackObjectGenerator" || attributeName == "MessagePackObjectGeneratorAttribute")
                        {
                            CandidateClasses.Add(classDeclaration);
                            return;
                        }
                    }
                }
            }
        }
    }
}